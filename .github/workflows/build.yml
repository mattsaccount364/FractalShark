name: Build

on:
  push:
    branches: ["**"]
    tags:
      - "*"
  pull_request:
  workflow_dispatch:

permissions:
  contents: write
  id-token: write        # allows OIDC token minting for signing
  attestations: write    # allows uploading the attestation to GitHub

jobs:
  build:
    name: Build FractalShark
    runs-on: windows-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Checkout MPIR
        uses: actions/checkout@v4
        with:
          repository: BrianGladman/mpir
          path: mpir
          submodules: true

      - name: Initialize MPIR submodules
        working-directory: mpir
        run: git submodule update --init --recursive

      - name: Install MiKTeX
        shell: pwsh
        run: |
          choco install miktex -y --no-progress

          $miktex = "C:\Program Files\MiKTeX\miktex\bin\x64"
          if (-not (Test-Path $miktex)) { throw "MiKTeX bin dir not found at $miktex" }

          # Make it available in THIS step and later steps
          $env:PATH = "$miktex;$env:PATH"
          $miktex | Out-File -FilePath $env:GITHUB_PATH -Append

          # Configure MiKTeX for CI use
          initexmf --admin --set-config-value=[MPM]AutoInstall=1
          initexmf --admin --set-config-value=[MPM]InstallOnTheFly=1
          initexmf --admin --set-config-value=[MPM]AskForInstall=0

      - name: Build notes.pdf
        shell: pwsh
        working-directory: Notes
        run: |
          pdflatex -interaction=nonstopmode -halt-on-error notes.tex
          bibtex notes
          pdflatex -interaction=nonstopmode -halt-on-error notes.tex
          pdflatex -interaction=nonstopmode -halt-on-error notes.tex

      - name: Verify notes.pdf exists
        shell: pwsh
        run: |
          $pdf = "Notes\notes.pdf"
          if (-not (Test-Path $pdf)) {
            throw "PDF not generated: $pdf"
          }
          Get-Item $pdf | Format-List FullName, Length

      - name: Upload notes PDF
        uses: actions/upload-artifact@v4
        with:
          name: FractalSharkNotes
          path: Notes/notes.pdf

      - name: Install VC++ 2010 runtime (for vsyasm)
        shell: pwsh
        run: |
          choco install vcredist2010 -y

      - name: Set up MSBuild
        uses: microsoft/setup-msbuild@v2

      # ---- Tooling MPIR expects ----
      - name: Install NuGet
        uses: nuget/setup-nuget@v2

      # Note 2025-12: Tried various current vsyasm but failed.  Just
      # keeping custom one for now.
      - name: Extract bundled tools to Program Files
        shell: pwsh
        run: |
          $zip = Join-Path $env:GITHUB_WORKSPACE "tools\yasm.zip"
          $dst = "C:\Program Files\vsyasm"

          Write-Host "ZIP path: $zip"
          if (-not (Test-Path $zip)) {
            throw "Zip not found at $zip. Check repo path/casing and that the file is committed."
          }

          $item = Get-Item $zip
          Write-Host ("Zip size: {0:n0} bytes" -f $item.Length)

          # Detect Git LFS pointer (typically tiny and starts with 'version https://git-lfs.github.com/spec/v1')
          $firstLine = (Get-Content -Path $zip -TotalCount 1 -ErrorAction SilentlyContinue)
          if ($item.Length -lt 2000 -and $firstLine -like "version https://git-lfs.github.com/spec/v1*") {
            throw "This file is a Git LFS pointer, not the real zip. Fix: set actions/checkout@v4 with `lfs: true`."
          }

          # Clean install location
          if (Test-Path $dst) { Remove-Item -Recurse -Force $dst }
          New-Item -ItemType Directory -Force -Path $dst | Out-Null

          # Unzip
          Expand-Archive -Path $zip -DestinationPath $dst -Force

          # Unblock extracted EXEs (Windows MOTW)
          Get-ChildItem -Path $dst -Recurse -File | Unblock-File

          # Find the actual bin dir (handles nested folders inside the zip)
          $exe = Get-ChildItem -Path $dst -Recurse -Filter "vsyasm.exe" -File | Select-Object -First 1
          if (-not $exe) { throw "vsyasm.exe not found anywhere under $dst after unzip." }

          $binDir = $exe.Directory.FullName
          Write-Host "Using bin dir: $binDir"
          Get-ChildItem $binDir | Format-Table -AutoSize

          # PATH + env vars for later steps
          $binDir | Out-File -FilePath $env:GITHUB_PATH -Append
          "YASMInstallDir=$binDir\"  | Out-File -FilePath $env:GITHUB_ENV -Append
          "YASMINSTALLDIR=$binDir\"  | Out-File -FilePath $env:GITHUB_ENV -Append
          "YASM_PATH=$binDir\"       | Out-File -FilePath $env:GITHUB_ENV -Append

          try {
            & $exe.FullName /?
          } catch {
            # ignore
          }
          $LASTEXITCODE = 0

      # Originally it wouldn't load.  Used this to sort out it was missing the VC runtime dependency.
      - name: Dump DLL dependencies (vsyasm)
        shell: pwsh
        run: |
          $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          if (-not (Test-Path $vswhere)) {
            throw "vswhere.exe not found"
          }

          $vsPath = & $vswhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
          if (-not $vsPath) {
            throw "Visual Studio with VC tools not found"
          }

          $vcvars = Join-Path $vsPath "VC\Auxiliary\Build\vcvars64.bat"
          if (-not (Test-Path $vcvars)) {
            throw "vcvars64.bat not found"
          }

          cmd /c "`"$vcvars`" >nul && dumpbin /dependents `"C:\Program Files\vsyasm\vsyasm.exe`""

      # See if the damn thing runs
      - name: Verify vsyasm/yasm are visible
        shell: pwsh
        run: |
          Write-Host "YASM_PATH: $env:YASM_PATH"
          Get-Command vsyasm.exe -ErrorAction Stop | Format-List
          Get-Command yasm.exe   -ErrorAction SilentlyContinue | Format-List

      - name: Try running vsyasm directly (diagnostic)
        shell: pwsh
        continue-on-error: true
        run: |
          & "C:\Program Files\vsyasm\vsyasm.exe" --version
          Write-Host "Exit code: $LASTEXITCODE"

      # ---- Build MPIR (official entrypoint) ----
      - name: Build MPIR (skylake_avx, Release x64)
        working-directory: mpir\msvc\vs22
        shell: cmd
        run: msbuild.bat skylake_avx LIB x64 Release

      - name: Build MPIR (skylake_avx, Debug x64)
        working-directory: mpir\msvc\vs22
        shell: cmd
        run: msbuild.bat skylake_avx LIB x64 Debug

      # ---- CUDA ----
      - name: Install CUDA Toolkit
        uses: Jimver/cuda-toolkit@v0.2.29
        with:
          cuda: "13.0.2"

      # ---- Build FractalShark ----
      - name: Build Debug
        run: msbuild FractalShark\FractalShark.sln /m /v:m /p:Configuration=Debug /p:Platform=x64 /p:PlatformToolset=v143

      - name: Build Release
        run: msbuild FractalShark\FractalShark.sln /m /v:m /p:Configuration=Release /p:Platform=x64 /p:PlatformToolset=v143

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: FractalShark-build
          path: |
            **/Release/**
            **/x64/Release/**
            **/Debug/**
            **/x64/Debug/**
            # Notes/notes.pdf  # (optional) include notes in this artifact again

  release:
    name: Create FractalShark Release
    runs-on: windows-latest
    needs: build
    if: startsWith(github.ref, 'refs/tags/')

    steps:
      - name: "Diagnostic: environment + context"
        shell: pwsh
        run: |
          Write-Host "=== GitHub Context ==="
          Write-Host "GITHUB_REF       = $env:GITHUB_REF"
          Write-Host "GITHUB_REF_NAME  = $env:GITHUB_REF_NAME"
          Write-Host "GITHUB_SHA       = $env:GITHUB_SHA"
          Write-Host "GITHUB_WORKSPACE = $env:GITHUB_WORKSPACE"
          Write-Host "Runner OS        = $env:RUNNER_OS"
          Write-Host "Runner Arch      = $env:RUNNER_ARCH"

          Write-Host "`n=== Directory listing (workspace root) ==="
          Get-ChildItem -Force | Format-Table -AutoSize

          Write-Host "`n=== PowerShell version ==="
          $PSVersionTable

      - name: Checkout repo (needed for gh/git context)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "Diagnostic: git state"
        shell: pwsh
        run: |
          Write-Host "=== Git version ==="
          git --version

          Write-Host "`n=== Is this a git repo? ==="
          git rev-parse --is-inside-work-tree

          Write-Host "`n=== HEAD ==="
          git log -1 --oneline

          Write-Host "`n=== Tags ==="
          git tag --list

          Write-Host "`n=== Status ==="
          git status --porcelain=v1

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: FractalShark-build
          path: dist

      # Keep downloading notes as a separate artifact (still generated),
      # but do NOT put it into out/zip/release.
      - name: Download notes PDF artifact (kept separate; not released)
        uses: actions/download-artifact@v4
        with:
          name: FractalSharkNotes
          path: _notes_art

      # If you ever want to re-include notes in packaging, uncomment this block to
      # normalize it into Notes\notes.pdf and then include it in the zip/release steps.
      #
      # - name: Normalize notes.pdf path
      #   shell: pwsh
      #   run: |
      #     $found = Get-ChildItem -Path _notes_art -Recurse -Filter notes.pdf -File | Select-Object -First 1
      #     if (-not $found) { throw "notes.pdf not found under _notes_art" }
      #
      #     New-Item -ItemType Directory -Force -Path Notes | Out-Null
      #     Copy-Item $found.FullName "Notes\notes.pdf" -Force

      - name: "Diagnostic: artifact layout"
        shell: pwsh
        run: |
          Write-Host "=== dist tree ==="
          if (Test-Path dist) {
            Get-ChildItem dist -Recurse | Format-Table FullName, Length
          } else {
            Write-Error "dist directory does not exist"
          }

          Write-Host "`n=== _notes_art tree (notes kept separate) ==="
          if (Test-Path _notes_art) {
            Get-ChildItem _notes_art -Recurse | Format-Table FullName, Length
          }

      - name: Package artifacts (zip)
        shell: pwsh
        run: |
          $releaseDir = Join-Path $PWD "dist\Release"
          $exeSrc   = Join-Path $releaseDir "FractalShark.exe"
          $pdbSrc   = Join-Path $releaseDir "FractalShark.pdb"

          # Optional: notes (would require Normalize step above)
          # $pdfSrc   = Join-Path $PWD "Notes\notes.pdf"

          Write-Host "Release dir: $releaseDir"
          Write-Host "EXE source: $exeSrc"
          Write-Host "PDB source: $pdbSrc"
          # Write-Host "PDF source: $pdfSrc"

          if (-not (Test-Path $exeSrc)) { throw "Missing: $exeSrc" }
          if (-not (Test-Path $pdbSrc)) { throw "Missing: $pdbSrc" }
          # if (-not (Test-Path $pdfSrc)) { throw "Missing: $pdfSrc (did the Normalize step run?)" }

          New-Item -ItemType Directory -Force -Path out | Out-Null

          $exeDst = Join-Path $PWD "out\FractalShark.exe"
          $pdbDst = Join-Path $PWD "out\FractalShark.pdb"
          Copy-Item $exeSrc $exeDst -Force
          Copy-Item $pdbSrc $pdbDst -Force

          # $pdfDst = Join-Path $PWD "out\notes.pdf"
          # Copy-Item $pdfSrc $pdfDst -Force

          $zip = "out\FractalShark-$env:GITHUB_REF_NAME.zip"

          Compress-Archive -Path "out\FractalShark.exe","out\FractalShark.pdb" `
                           -DestinationPath $zip -Force

          # To include notes again:
          # Compress-Archive -Path "out\FractalShark.exe","out\FractalShark.pdb","out\notes.pdf" `
          #                  -DestinationPath $zip -Force

          Write-Host "`n=== out directory ==="
          Get-ChildItem out | Format-Table -AutoSize

          Write-Host "`n=== ZIP verification ==="
          if (-not (Test-Path $zip)) { throw "ZIP not created: $zip" }

          Write-Host "ZIP contents:"
          Expand-Archive -Path $zip -DestinationPath out\_verify -Force
          Get-ChildItem out\_verify | Format-Table -AutoSize

      - name: Verify ZIP exists (pre-attestation)
        shell: pwsh
        run: |
          $p = "out\FractalShark-$env:GITHUB_REF_NAME.zip"
          if (-not (Test-Path $p)) { throw "ZIP not found: $p" }

      - name: Generate build provenance attestation (ZIP)
        uses: actions/attest-build-provenance@v3
        with:
          subject-path: out/FractalShark-${{ github.ref_name }}.zip

      - name: "Diagnostic: gh auth + version"
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          Write-Host "=== gh version ==="
          gh --version

          Write-Host "`n=== gh auth status ==="
          gh auth status

          Write-Host "`n=== gh release view (pre-flight) ==="
          gh release view "$env:GITHUB_REF_NAME"
          if ($LASTEXITCODE -ne 0) {
            Write-Host "Release does not exist yet (expected)"
            $global:LASTEXITCODE = 0
          }

      - name: Delete and recreate Release (always overwrite)
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $tag = $env:GITHUB_REF_NAME
          $zip = "out\FractalShark-$tag.zip"

          if (-not (Test-Path $zip)) { throw "Missing asset: $zip" }

          # Optional: attach notes to the GitHub Release too
          # $pdf = "out\notes.pdf"
          # if (-not (Test-Path $pdf)) { throw "Missing asset: $pdf" }

          $title = "FractalShark $tag"
          $notes = "Automated release for $tag"

          Write-Host "Tag:   $tag"
          Write-Host "Asset: $zip"
          # Write-Host "Asset: $pdf"

          Write-Host "Deleting existing release if present..."
          gh release delete "$tag" --yes 2>$null
          $LASTEXITCODE = 0

          Write-Host "Creating release..."
          gh release create "$tag" `
            --verify-tag `
            --title "$title" `
            --notes "$notes" `
            "$zip"

          # To attach notes again:
          # gh release create "$tag" `
          #   --verify-tag `
          #   --title "$title" `
          #   --notes "$notes" `
          #   "$zip" "$pdf"
