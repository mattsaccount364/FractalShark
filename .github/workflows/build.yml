name: Build

on:
  push:
    branches: ["**"]
    tags:
      - "*"
  pull_request:
  workflow_dispatch:

permissions:
  contents: write
  id-token: write        # allows OIDC token minting for signing
  attestations: write    # allows uploading the attestation to GitHub

jobs:
  # ---- PDF notes (runs in parallel with code builds) ----
  build-pdf:
    name: Build PDF Notes
    runs-on: windows-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Install MiKTeX
        shell: pwsh
        run: |
          choco install miktex -y --no-progress

          $miktex = "C:\Program Files\MiKTeX\miktex\bin\x64"
          if (-not (Test-Path $miktex)) { throw "MiKTeX bin dir not found at $miktex" }

          # Make it available in THIS step and later steps
          $env:PATH = "$miktex;$env:PATH"
          $miktex | Out-File -FilePath $env:GITHUB_PATH -Append

          # Configure MiKTeX for CI use
          initexmf --admin --set-config-value=[MPM]AutoInstall=1
          initexmf --admin --set-config-value=[MPM]InstallOnTheFly=1
          initexmf --admin --set-config-value=[MPM]AskForInstall=0

      - name: Build FractalShark.pdf
        shell: pwsh
        working-directory: Notes
        run: |
          pdflatex -interaction=nonstopmode -halt-on-error FractalShark.tex
          bibtex FractalShark
          pdflatex -interaction=nonstopmode -halt-on-error FractalShark.tex
          pdflatex -interaction=nonstopmode -halt-on-error FractalShark.tex

      - name: Verify FractalShark.pdf exists
        shell: pwsh
        run: |
          $pdf = "Notes\FractalShark.pdf"
          if (-not (Test-Path $pdf)) {
            throw "PDF not generated: $pdf"
          }
          Get-Item $pdf | Format-List FullName, Length

      - name: Upload FractalShark PDF
        uses: actions/upload-artifact@v4
        with:
          name: FractalSharkNotes
          path: Notes/FractalShark.pdf

  # ---- Code build (Debug and Release run as parallel matrix legs) ----
  build:
    name: Build FractalShark (${{ matrix.configuration }})
    runs-on: windows-latest

    strategy:
      fail-fast: false
      matrix:
        configuration: [Debug, Release]

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Checkout MPIR
        uses: actions/checkout@v4
        with:
          repository: BrianGladman/mpir
          path: mpir
          submodules: true

      - name: Initialize MPIR submodules
        working-directory: mpir
        run: git submodule update --init --recursive

      - name: Install VC++ 2010 runtime (for vsyasm)
        shell: pwsh
        run: |
          choco install vcredist2010 -y

      - name: Set up MSBuild
        uses: microsoft/setup-msbuild@v2

      # ---- Tooling MPIR expects ----
      - name: Install NuGet
        uses: nuget/setup-nuget@v2

      # Note 2025-12: Tried various current vsyasm but failed.  Just
      # keeping custom one for now.
      - name: Extract bundled tools to Program Files
        shell: pwsh
        run: |
          $zip = Join-Path $env:GITHUB_WORKSPACE "tools\yasm.zip"
          $dst = "C:\Program Files\vsyasm"

          Write-Host "ZIP path: $zip"
          if (-not (Test-Path $zip)) {
            throw "Zip not found at $zip. Check repo path/casing and that the file is committed."
          }

          $item = Get-Item $zip
          Write-Host ("Zip size: {0:n0} bytes" -f $item.Length)

          # Detect Git LFS pointer (typically tiny and starts with 'version https://git-lfs.github.com/spec/v1')
          $firstLine = (Get-Content -Path $zip -TotalCount 1 -ErrorAction SilentlyContinue)
          if ($item.Length -lt 2000 -and $firstLine -like "version https://git-lfs.github.com/spec/v1*") {
            throw "This file is a Git LFS pointer, not the real zip. Fix: set actions/checkout@v4 with `lfs: true`."
          }

          # Clean install location
          if (Test-Path $dst) { Remove-Item -Recurse -Force $dst }
          New-Item -ItemType Directory -Force -Path $dst | Out-Null

          # Unzip
          Expand-Archive -Path $zip -DestinationPath $dst -Force

          # Unblock extracted EXEs (Windows MOTW)
          Get-ChildItem -Path $dst -Recurse -File | Unblock-File

          # Find the actual bin dir (handles nested folders inside the zip)
          $exe = Get-ChildItem -Path $dst -Recurse -Filter "vsyasm.exe" -File | Select-Object -First 1
          if (-not $exe) { throw "vsyasm.exe not found anywhere under $dst after unzip." }

          $binDir = $exe.Directory.FullName
          Write-Host "Using bin dir: $binDir"
          Get-ChildItem $binDir | Format-Table -AutoSize

          # PATH + env vars for later steps
          $binDir | Out-File -FilePath $env:GITHUB_PATH -Append
          "YASMInstallDir=$binDir\"  | Out-File -FilePath $env:GITHUB_ENV -Append
          "YASMINSTALLDIR=$binDir\"  | Out-File -FilePath $env:GITHUB_ENV -Append
          "YASM_PATH=$binDir\"       | Out-File -FilePath $env:GITHUB_ENV -Append
          "YASM_NAME=vsyasm.exe"     | Out-File -FilePath $env:GITHUB_ENV -Append

          try {
            & $exe.FullName /?
          } catch {
            # ignore
          }
          $LASTEXITCODE = 0

      # Originally it wouldn't load.  Used this to sort out it was missing the VC runtime dependency.
      - name: Dump DLL dependencies (vsyasm)
        shell: pwsh
        run: |
          $vswhere = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
          if (-not (Test-Path $vswhere)) {
            throw "vswhere.exe not found"
          }

          $vsPath = & $vswhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
          if (-not $vsPath) {
            throw "Visual Studio with VC tools not found"
          }

          $vcvars = Join-Path $vsPath "VC\Auxiliary\Build\vcvars64.bat"
          if (-not (Test-Path $vcvars)) {
            throw "vcvars64.bat not found"
          }

          cmd /c "`"$vcvars`" >nul && dumpbin /dependents `"C:\Program Files\vsyasm\vsyasm.exe`""

      # See if the damn thing runs
      - name: Verify vsyasm/yasm are visible
        shell: pwsh
        run: |
          Write-Host "YASM_PATH: $env:YASM_PATH"
          Get-Command vsyasm.exe -ErrorAction Stop | Format-List
          Get-Command yasm.exe   -ErrorAction SilentlyContinue | Format-List

      - name: Try running vsyasm directly (diagnostic)
        shell: pwsh
        continue-on-error: true
        run: |
          & "C:\Program Files\vsyasm\vsyasm.exe" --version
          Write-Host "Exit code: $LASTEXITCODE"

      # ---- Cache MPIR build outputs ----
      - name: Cache MPIR build
        id: mpir-cache
        uses: actions/cache@v4
        with:
          path: mpir/lib/x64/${{ matrix.configuration }}
          key: mpir-${{ runner.os }}-skylake-avx-x64-${{ matrix.configuration }}-${{ hashFiles('mpir/**/*.c', 'mpir/**/*.h', 'mpir/**/*.asm') }}

      # ---- Build MPIR (official entrypoint) ----
      - name: Build MPIR (skylake_avx, ${{ matrix.configuration }} x64)
        if: steps.mpir-cache.outputs.cache-hit != 'true'
        working-directory: mpir\msvc\vs22
        shell: cmd
        run: msbuild.bat skylake_avx LIB x64 ${{ matrix.configuration }}

      # ---- CUDA ----
      - name: Install CUDA Toolkit
        uses: Jimver/cuda-toolkit@v0.2.29
        with:
          cuda: "13.0.2"

      # ---- Build FractalShark ----
      - name: Build ${{ matrix.configuration }}
        run: msbuild FractalShark\FractalShark.sln /m /v:m /p:Configuration=${{ matrix.configuration }} /p:Platform=x64 /p:PlatformToolset=v143

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: FractalShark-${{ matrix.configuration }}
          path: |
            **/${{ matrix.configuration }}/**
            **/x64/${{ matrix.configuration }}/**

  release:
    name: Create FractalShark Release
    runs-on: windows-latest
    needs: [build, build-pdf]
    if: startsWith(github.ref, 'refs/tags/')

    steps:
      - name: "Diagnostic: environment + context"
        shell: pwsh
        run: |
          Write-Host "=== GitHub Context ==="
          Write-Host "GITHUB_REF       = $env:GITHUB_REF"
          Write-Host "GITHUB_REF_NAME  = $env:GITHUB_REF_NAME"
          Write-Host "GITHUB_SHA       = $env:GITHUB_SHA"
          Write-Host "GITHUB_WORKSPACE = $env:GITHUB_WORKSPACE"
          Write-Host "Runner OS        = $env:RUNNER_OS"
          Write-Host "Runner Arch      = $env:RUNNER_ARCH"

          Write-Host "`n=== Directory listing (workspace root) ==="
          Get-ChildItem -Force | Format-Table -AutoSize

          Write-Host "`n=== PowerShell version ==="
          $PSVersionTable

      - name: Checkout repo (needed for gh/git context)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: "Diagnostic: git state"
        shell: pwsh
        run: |
          Write-Host "=== Git version ==="
          git --version

          Write-Host "`n=== Is this a git repo? ==="
          git rev-parse --is-inside-work-tree

          Write-Host "`n=== HEAD ==="
          git log -1 --oneline

          Write-Host "`n=== Tags ==="
          git tag --list

          Write-Host "`n=== Status ==="
          git status --porcelain=v1

      - name: Download Release build artifacts
        uses: actions/download-artifact@v4
        with:
          name: FractalShark-Release
          path: dist

      - name: Download FractalShark notes PDF artifact
        uses: actions/download-artifact@v4
        with:
          name: FractalSharkNotes
          path: _notes_art

      - name: Normalize FractalShark.pdf path
        shell: pwsh
        run: |
          $found = Get-ChildItem -Path _notes_art -Recurse -Filter FractalShark.pdf -File | Select-Object -First 1
          if (-not $found) { throw "FractalShark.pdf not found under _notes_art" }
      
          New-Item -ItemType Directory -Force -Path Notes | Out-Null
          Copy-Item $found.FullName "Notes\FractalShark.pdf" -Force

      - name: "Diagnostic: artifact layout"
        shell: pwsh
        run: |
          Write-Host "=== dist tree ==="
          if (Test-Path dist) {
            Get-ChildItem dist -Recurse | Format-Table FullName, Length
          } else {
            Write-Error "dist directory does not exist"
          }

          Write-Host "`n=== _notes_art tree (notes kept separate) ==="
          if (Test-Path _notes_art) {
            Get-ChildItem _notes_art -Recurse | Format-Table FullName, Length
          }

      - name: Package artifacts (zip)
        shell: pwsh
        run: |
          # --- locate built binaries robustly (artifact layout may vary) ---
          $exe = Get-ChildItem dist -Recurse -Filter FractalShark.exe -File | Select-Object -First 1
          if (-not $exe) { throw "FractalShark.exe not found anywhere under dist" }

          $pdb = Get-ChildItem dist -Recurse -Filter FractalShark.pdb -File | Select-Object -First 1
          if (-not $pdb) { throw "FractalShark.pdb not found anywhere under dist" }

          $pdfSrc = Join-Path $PWD "Notes\FractalShark.pdf"
          if (-not (Test-Path $pdfSrc)) {
            throw "FractalShark.pdf missing at $pdfSrc (Normalize step failed?)"
          }

          Write-Host "Using EXE: $($exe.FullName)"
          Write-Host "Using PDB: $($pdb.FullName)"
          Write-Host "Using PDF: $pdfSrc"

          # --- stage outputs ---
          New-Item -ItemType Directory -Force -Path out | Out-Null

          Copy-Item $exe.FullName "out\FractalShark.exe" -Force
          Copy-Item $pdb.FullName "out\FractalShark.pdb" -Force
          Copy-Item $pdfSrc       "out\FractalShark.pdf"        -Force

          $zip = "out\FractalShark-$env:GITHUB_REF_NAME.zip"

          # --- create final release zip (exe + pdb + notes) ---
          Compress-Archive `
            -Path "out\FractalShark.exe","out\FractalShark.pdb","out\FractalShark.pdf" `
            -DestinationPath $zip `
            -Force

          Write-Host "`n=== out directory ==="
          Get-ChildItem out | Format-Table -AutoSize

          Write-Host "`n=== ZIP verification ==="
          if (-not (Test-Path $zip)) { throw "ZIP not created: $zip" }

          Expand-Archive -Path $zip -DestinationPath out\_verify -Force
          Get-ChildItem out\_verify | Format-Table -AutoSize

      - name: Verify ZIP exists (pre-attestation)
        shell: pwsh
        run: |
          $p = "out\FractalShark-$env:GITHUB_REF_NAME.zip"
          if (-not (Test-Path $p)) { throw "ZIP not found: $p" }

      - name: Generate build provenance attestation (ZIP)
        uses: actions/attest-build-provenance@v3
        with:
          subject-path: out/FractalShark-${{ github.ref_name }}.zip

      - name: "Diagnostic: gh auth + version"
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          Write-Host "=== gh version ==="
          gh --version

          Write-Host "`n=== gh auth status ==="
          gh auth status

          Write-Host "`n=== gh release view (pre-flight) ==="
          gh release view "$env:GITHUB_REF_NAME"
          if ($LASTEXITCODE -ne 0) {
            Write-Host "Release does not exist yet (expected)"
            $global:LASTEXITCODE = 0
          }

      - name: Delete and recreate Release (always overwrite)
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $tag = $env:GITHUB_REF_NAME
          $zip = "out\FractalShark-$tag.zip"

          if (-not (Test-Path $zip)) { throw "Missing asset: $zip" }

          $pdf = "out\FractalShark.pdf"
          if (-not (Test-Path $pdf)) { throw "Missing asset: $pdf" }

          $title = "FractalShark $tag"
          $notes = "Automated release for $tag"

          Write-Host "Tag:   $tag"
          Write-Host "Asset: $zip"
          Write-Host "Asset: $pdf"

          Write-Host "Deleting existing release if present..."
          gh release delete "$tag" --yes 2>$null
          $LASTEXITCODE = 0

          Write-Host "Creating release..."
          gh release create "$tag" `
            --verify-tag `
            --title "$title" `
            --notes "$notes" `
            "$zip" "$pdf"
