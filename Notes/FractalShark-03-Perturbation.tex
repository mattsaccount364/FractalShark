\section{Perturbation Rendering of the Mandelbrot Set}
\label{sec:perturbation-concept}

Rendering the Mandelbrot set (\cref{sec:mandelbrot-intro}) at extreme zoom levels presents a fundamental
numerical challenge. As the image is magnified, the parameters \(c\) associated
with individual pixels differ by increasingly small amounts, while the number
of iterations required to determine escape behavior typically grows. Accurately
tracking these orbits therefore requires both high numerical precision and a
large number of iterations, making naive per-pixel evaluation prohibitively
expensive.

Perturbation provides a mathematical and algorithmic framework
\cite{Martin2013Perturbation,HeilandAllen2013Perturbation,Wikibooks_Perturbation}
that addresses
this challenge by exploiting the strong coherence between nearby orbits. Rather
than evaluating each pixel independently at full precision, perturbation
separates the computation into a shared high-precision component and many
pixel-local low-precision components. This section introduces the perturbation
approach and explains how it enables efficient deep-zoom Mandelbrot rendering.

\subsection{Baseline iteration and its limitations}

The Mandelbrot set is defined by the iteration
\begin{equation}
z_{n+1} = z_n^2 + c, \qquad z_0 = 0,
\end{equation}
where \(c \in \mathbb{C}\) is the parameter associated with a pixel and the orbit
\(\{z_n\}\) is iterated until either escape is detected or a maximum iteration
count is reached.

At modest zoom levels, this iteration can be evaluated accurately using standard
floating-point arithmetic. At deep zoom levels, however, the differences between
nearby parameters \(c\) may be many orders of magnitude smaller than the values
of \(z_n\) encountered during iteration. In such regimes, rounding error and
loss of significance make fixed-precision arithmetic unreliable. While arbitrary
precision arithmetic can restore accuracy, applying it independently to every
pixel scales poorly.

\subsection{Coherence of nearby orbits}

A key observation underlying perturbation is that nearby parameters generate
orbits that remain close for many iterations. In a typical image tile, all pixel
parameters \(c\) lie within a small neighborhood of a central value. Their
orbits therefore share a common large-scale structure, differing only by small
corrections that grow gradually over time.

Perturbation makes this structure explicit by selecting a single
\emph{reference parameter} and expressing all nearby orbits relative to it. This
transforms the problem from one of many independent high-precision computations
into one of a single high-precision computation plus many low-precision updates.

\subsection{Reference orbit}

Let \(c_\star\) denote a reference parameter, typically chosen as the center of
the image region. Its orbit is computed using sufficiently high precision to
serve as a reliable baseline:
\begin{equation}
z_{n+1}^\star = (z_n^\star)^2 + c_\star, \qquad z_0^\star = 0.
\end{equation}
The sequence \(\{z_n^\star\}\) is stored and reused for all pixels within the
region. Because this orbit underpins the evaluation of many pixels, its
accuracy is critical.

\subsection{Perturbation as a mixed-precision decomposition}
\label{subsec:perturbation-mixed-precision}

For a nearby pixel parameter \(c = c_\star + \Delta c\), the orbit can be written
as a small deviation from the reference orbit:
\begin{equation}
z_n = z_n^\star + \Delta z_n.
\end{equation}
Substituting this expression into the Mandelbrot recurrence yields an exact
update rule for the deviation:
\begin{equation}
\Delta z_{n+1}
= 2 z_n^\star \Delta z_n + (\Delta z_n)^2 + \Delta c.
\label{eq:perturb-exact}
\end{equation}
No approximation has been introduced: as long as the reference orbit is computed
accurately, this formulation preserves the exact Mandelbrot dynamics.

This decomposition has an important numerical consequence. The reference orbit
\(z_n^\star\) typically grows in magnitude and requires arbitrary precision to be
represented accurately at deep zoom. In contrast, the deviation \(\Delta z_n\)
remains small for many iterations and can usually be evolved using much lower
precision arithmetic. Perturbation therefore reorganizes the computation into a
mixed-precision pipeline: expensive high-precision arithmetic is concentrated in
a single shared orbit, while the majority of per-pixel work is performed using
lower precision with significantly higher throughput.

\subsection{Real-valued formulation for implementation}

For practical implementation, particularly on GPUs, it is convenient to express
the perturbation update in real arithmetic. Writing
\begin{align*}
z_n^\star &= x_n^\star + i y_n^\star, \\
\Delta z_n &= \Delta x_n + i \Delta y_n, \\
\Delta c &= \Delta c_x + i \Delta c_y,
\end{align*}
and expanding \cref{eq:perturb-exact} yields
\begin{align}
\Delta x_{n+1}
&= 2(x_n^\star \Delta x_n - y_n^\star \Delta y_n)
   + (\Delta x_n^2 - \Delta y_n^2)
   + \Delta c_x, \\
\Delta y_{n+1}
&= 2(x_n^\star \Delta y_n + y_n^\star \Delta x_n)
   + 2 \Delta x_n \Delta y_n
   + \Delta c_y.
\end{align}
These equations map directly onto scalar arithmetic and can be evaluated
efficiently in parallel for many pixels.

\subsection{Reconstruction and escape testing}

Although perturbation evolves only the deviation \(\Delta z_n\), escape-time
rendering requires testing the magnitude of the full orbit value. At each
iteration, the current iterate is reconstructed as
\begin{equation}
z_n = z_n^\star + \Delta z_n,
\end{equation}
and the standard Mandelbrot bailout condition is applied:
\begin{equation}
|z_n|^2 \ge 4.
\end{equation}
The iteration at which this condition is first satisfied determines the pixelâ€™s
escape time.

\subsection{Numerical stability and rebasing}

Perturbation remains efficient only while the deviation \(\Delta z_n\) remains
small relative to the reference orbit. As the deviation grows, numerical
cancellation and loss of significance may occur. Practical implementations
therefore employ \emph{rebasing} \cite{Zhuoran2023ReferenceCompression,HeilandAllen2022DeepZoom},
in which the current deviation
is folded into the reference state and perturbation continues relative to this
new baseline. This process preserves accuracy while maintaining numerical
stability.

\subsection{Relation to other acceleration techniques}

Perturbation preserves the exact dynamics of the Mandelbrot map and forms the
foundation of many advanced deep-zoom rendering techniques. It can be used by
itself (\cref{sec:perturb-only}) or combined with additional approximations, such as bilinear approximation
(\cref{sec:bilinear-approx}) or linear approximation (\cref{sec:la-v2-perturb}),
to skip multiple iterations at once. In all cases, perturbation provides
the conceptual framework that makes efficient deep-zoom Mandelbrot rendering
possible.

\paragraph{Terminology note: HDR scalar representation.}
In this work, the term \emph{HDR} refers to a \emph{high-dynamic-range} numeric
representation that pairs a fixed-precision mantissa (float or double) with an
explicitly managed integer exponent (see below for the full description).  When the GPU reference-orbit kernel or
perturbation pipeline needs lightweight control-flow decisions---periodicity
detection, escape testing, magnitude comparisons---it converts the full
arbitrary-precision state into an HDR value via a lossy reduction step
(\code{ToHDRFloat}).  The resulting HDR value preserves a wide exponent range,
sufficient to compare magnitudes spanning many orders of magnitude, but carries
only the fixed mantissa precision of the underlying float type rather than the
full arbitrary-precision mantissa.  The use of the term HDR here is purely
numerical and is unrelated to high-dynamic-range imaging.

\section{Perturbation-only Mandelbrot rendering (without linear approximation)}
\label{sec:perturb-only}

This kernel can render the Mandelbrot set using \emph{perturbation alone}, i.e.,
without taking any LA v2 linear-approximation steps. The same CUDA entry point
\code{mandel\_1xHDR\_float\_perturb\_lav2<IterType,T,SubType,Mode,PExtras>} is
used; the behavior is selected at compile time via \code{LAv2Mode}. In
particular, when \code{Mode} includes only the perturbation path (e.g.\
\code{LAv2Mode::PO}), the kernel skips the LA stage traversal and runs only the
perturbation loop against a stored reference orbit (\cref{sec:ref-orbit-calc}).

\subsection{Rendering objective}
\label{sec:perturb-only-goal}

The goal remains standard escape-time rendering for
\[
z_{n+1} = z_n^2 + c,\qquad z_0=0,
\]
with bailout \(|z|^2 \ge 4\). For each pixel, the kernel computes the parameter
\(c\), iterates until escape or \code{n\_iterations}, and stores the resulting
iteration count in \code{OutputIterMatrix[idx]}.

In perturbation rendering, the expensive high-precision orbit evaluation for
each pixel is avoided by reusing a \emph{reference orbit} computed at a
reference parameter \(c_\star\), then evolving only the \emph{delta orbit} for
nearby pixels.

\subsection{Reference orbit and delta formulation}
\label{sec:perturb-only-deltas}

Let the reference parameter be \(c_\star\), with stored reference orbit
\(\{z_n^\star\}\) satisfying
\[
z_{n+1}^\star = (z_n^\star)^2 + c_\star,\qquad z_0^\star=0.
\]
For a pixel parameter \(c\) near \(c_\star\), define the parameter delta
\[
\Delta c \stackrel{\mathrm{def}}{=} c - c_\star,
\]
and the orbit delta
\[
\Delta z_n \stackrel{\mathrm{def}}{=} z_n - z_n^\star.
\]
Substituting \(z_n = z_n^\star + \Delta z_n\) into the Mandelbrot recurrence
yields the \emph{exact} delta recurrence:
\begin{align}
\Delta z_{n+1}
&= (z_n^\star + \Delta z_n)^2 + (c_\star + \Delta c) - \left((z_n^\star)^2 + c_\star\right) \\
&= 2 z_n^\star\,\Delta z_n + (\Delta z_n)^2 + \Delta c.
\end{align}
Perturbation uses this recurrence directly: it is not a linearization. The work
per iteration is reduced because \(z_n^\star\) is fetched from storage rather
than recomputed in high precision.

\subsection{Pixel parameter delta \texorpdfstring{$\Delta c$}{Delta c}}
\label{sec:perturb-only-deltac}

For each pixel \((X,Y)\), the kernel constructs a delta parameter relative to a
chosen reference center (sign conventions incorporate the image mapping):
\begin{align}
\Delta c_x &= dx \cdot X - \code{centerX}, \\
\Delta c_y &= -dy \cdot Y - \code{centerY},
\end{align}
and stores this as \code{DeltaSub0} (with scalar components \code{DeltaSub0X},
\code{DeltaSub0Y}). The perturbation state starts at
\[
\Delta z_0 = 0,
\]
so \code{DeltaSubN} is initialized to zero.

\subsection{Perturbation recurrence used in the kernel}
\label{sec:perturb-only-update}

Writing the reference sample as \(z^\star = x^\star + i y^\star\) and the delta
as \(\Delta z = \Delta x + i \Delta y\), the delta recurrence can be expressed
in a factored form convenient for implementation:
\begin{equation}
\Delta z \leftarrow \Delta z \cdot (2 z^\star + \Delta z) + \Delta c.
\label{eq:perturb-factor}
\end{equation}
This identity is equivalent to
\(\Delta z_{n+1} = 2 z_n^\star \Delta z_n + (\Delta z_n)^2 + \Delta c\), because
\(\Delta z\cdot(2z^\star+\Delta z) = 2z^\star\Delta z + (\Delta z)^2\).

The kernel implements \cref{eq:perturb-factor} in real arithmetic by forming
the sums
\[
(2x^\star + \Delta x),\qquad (2y^\star + \Delta y),
\]
then updating:
\begin{align}
\Delta x' &= \Delta x\,(2x^\star + \Delta x) - \Delta y\,(2y^\star + \Delta y) + \Delta c_x, \\
\Delta y' &= \Delta x\,(2y^\star + \Delta y) + \Delta y\,(2x^\star + \Delta x) + \Delta c_y.
\end{align}
Note that both right-hand sides use the \emph{pre-update} values of
\(\Delta x\) and \(\Delta y\).  In the code, these originals are saved as
\code{DeltaSubNXOrig} and \code{DeltaSubNYOrig} before either component is
overwritten.  The intermediate quantities correspond to:
\begin{verbatim}
tempSum1 = 2*zy + DeltaSubNYOrig;  // (2 y^\star + \Delta y)
tempSum2 = 2*zx + DeltaSubNXOrig;  // (2 x^\star + \Delta x)
\end{verbatim}
followed by the real/imag updates. For extended or HDR types (\cref{sec:hdr-float}), the kernel routes
the same math through type-specialized implementations
(\code{T::custom\_perturb2} / \code{T::custom\_perturb3}) to keep the inner loop
tight and to enforce the type's reduction/normalization rules.

\subsection{Reconstructing the absolute orbit for escape testing}
\label{sec:perturb-only-reconstruct}

Perturbation evolves \(\Delta z_n\), but escape-time rendering requires a
bailout test on the absolute orbit \(z_n\). Each iteration reconstructs:
\[
z_n \approx z_n^\star + \Delta z_n,
\]
using the stored reference sample \(z_n^\star\) and the current delta. In the
kernel, this appears as:
\[
x = x^\star + \Delta x,\qquad y = y^\star + \Delta y.
\]
The bailout test is then performed on
\[
|z|^2 = x^2 + y^2,
\]
with the canonical threshold \(4\). For HDR and related types, the norm and the
comparison are performed on reduced values using specialized reduced
comparators to keep the escape decision stable at deep zoom.

\subsection{Reference index management and rebasing}
\label{sec:perturb-only-rebase}

The perturbation loop advances a reference-orbit index \code{RefIteration} in
lockstep with \code{iter}, fetching \(z^\star\) samples from \code{Perturb}. The
kernel includes a \emph{rebasing} mechanism that resets the delta
representation when it becomes ill-conditioned. Conceptually, if the delta
becomes comparable to or larger than the reconstructed orbit, the decomposition
\(z = z^\star + \Delta z\) stops being numerically advantageous. In that case,
the kernel folds the delta into the base by setting:
\[
\Delta z \leftarrow z,\qquad \text{and restart the reference index.}
\]
Operationally, the code compares the reconstructed orbit magnitude proxy
against the delta magnitude proxy, and also rebasing if the reference index
reaches the end of the stored orbit samples (to avoid out-of-range sampling).
After rebasing, perturbation continues from the new base representation.

This mechanism keeps the perturbation method usable across a wide range of
pixels and iteration depths while preserving the core rendering objective:
compute escape-time using a stable bailout on the reconstructed orbit.

\subsection{Using \code{LAv2Mode} to select perturbation-only execution}
\label{sec:perturb-only-mode}

The kernel is structured as two compile-time phases:
\begin{itemize}
\item an LA v2 phase guarded by \code{Mode == Full || Mode == LAO},
\item a perturbation phase guarded by \code{Mode == Full || Mode == PO}.
\end{itemize}
Therefore, perturbation-only rendering is achieved by instantiating the kernel
with a mode that includes only the perturbation path (e.g.\ \code{LAv2Mode::PO}).
In this configuration:
\begin{itemize}
\item \code{DeltaSub0} is computed from the pixel location,
\item \code{DeltaSubN} remains initialized to \(\Delta z_0 = 0\),
\item the kernel runs the perturbation loop, reconstructing \(z\) each step for
      bailout tests,
\item the final escape-time count is written to \code{OutputIterMatrix}.
\end{itemize}
This provides a complete Mandelbrot renderer based purely on reference-orbit
perturbation, without relying on any linear-approximation hierarchy.
After all pixels are computed, the antialiasing and reduction passes
(\cref{subsec:antialiasing,subsec:reduction}) extract the final colour
image and iteration statistics.


\section{Approximation-Based Orbit Acceleration}
\label{sec:approx-accel}

At deep zoom, the cost of iterating high-precision types for every pixel can be
dominant. The remaining components described below are still in service of the
same rendering goal: compute escape-time for \(z_{n+1}=z_n^2+c\), but by reusing
a \emph{reference orbit} and evolving \emph{deltas} for nearby pixels.

\subsection{Bilinear approximation (BLA) for orbit deltas}
\label{sec:bilinear-approx}

Bilinear approximation, originated by Heiland-Allen in Kalles
Fraktaler~2+ \cite{KallesFraktaler} and described in detail by
Thompson \cite{Thompson2023BLA}, precomputes composable linear
maps that advance the perturbation delta by multiple iterations at once,
avoiding per-step evaluation when the linearization error remains small.

\subsubsection{Reference orbit and delta formulation}
Let the reference parameter be \(c_\star\) with orbit
(see \cref{sec:perturbation-concept} for the general perturbation framework):
\[
z_{n+1}^\star = (z_n^\star)^2 + c_\star,\qquad z_0^\star=0.
\]
For a nearby pixel parameter \(c = c_\star + \Delta c\), define:
\[
\Delta z_n \stackrel{\mathrm{def}}{=} z_n - z_n^\star,\qquad
\Delta c \stackrel{\mathrm{def}}{=} c - c_\star.
\]
Expanding the recurrence gives:
\begin{align}
\Delta z_{n+1}
&= (z_n^\star + \Delta z_n)^2 + (c_\star + \Delta c) - \left((z_n^\star)^2 + c_\star\right)\\
&= 2 z_n^\star\,\Delta z_n + (\Delta z_n)^2 + \Delta c.
\end{align}
When \(\Delta z_n\) remains small, the quadratic term can be neglected,
yielding a linearized update:
\begin{equation}
\Delta z_{n+1} \approx A_n\,\Delta z_n + B_n\,\Delta c,\qquad
A_n = 2z_n^\star,\quad B_n = 1.
\end{equation}
BLA generalizes this into precomputed multi-step maps that \emph{jump} multiple
iterations while maintaining an explicit validity bound.

\subsubsection{What \code{BLA<T>} stores}
A \code{BLA<T>} instance stores two complex coefficients:
\[
A = A_x + iA_y,\qquad B = B_x + iB_y,
\]
plus:
\begin{itemize}
  \item \code{r2}: a squared-radius validity bound used during lookup,
  \item \code{l}: the number of Mandelbrot iterations summarized by this step.
\end{itemize}
These objects exist to accelerate \emph{escape-time evaluation} by evolving
\(\Delta z\) cheaply for many pixels, then reconstructing \(z \approx z^\star +
\Delta z\) to perform bailout checks consistent with Mandelbrot rendering.

\subsubsection{Applying a step: complex multiply-add}
The method \code{getValue} (taking arguments \code{RealDeltaSubN},
\code{ImagDeltaSubN}, \code{RealDeltaSub0}, \code{ImagDeltaSub0})
applies:
\[
\Delta z \leftarrow A\,\Delta z + B\,\Delta c,
\]
expanded into real arithmetic:
\begin{align}
\Re(\Delta z') &= A_x \Re(\Delta z) - A_y \Im(\Delta z) + B_x \Re(\Delta c) - B_y \Im(\Delta c), \\
\Im(\Delta z') &= A_x \Im(\Delta z) + A_y \Re(\Delta z) + B_x \Im(\Delta c) + B_y \Re(\Delta c).
\end{align}

\subsubsection{Composing steps to build longer jumps}
If a first step maps \(\Delta z \mapsto A_1\Delta z + B_1\Delta c\) and a second maps
\(\Delta z' \mapsto A_2\Delta z' + B_2\Delta c\), the composition is:
\[
A_{\text{new}} = A_2 A_1,\qquad B_{\text{new}} = A_2 B_1 + B_2.
\]
In the code (\code{BLA.h}), these two steps are passed as the parameters
\code{x} and \code{y} to \code{getNewA} and \code{getNewB}, corresponding to
step~1 and step~2 respectively.
This supports a hierarchy of step sizes (often powers of two) for quickly
advancing delta orbits while rendering the escape-time field.

\subsubsection{GPU lookup: selecting a valid aligned step}
A GPU-side helper such as \code{GPU\_BLAS} stores the hierarchy and selects a
step that is both \emph{aligned} with the current iteration index and
\emph{valid} under the current bound check (typically comparing a computed
squared-magnitude proxy \code{z2} against \code{r2}). When a step is valid, the
renderer can advance the orbit by \code{l} iterations at a cost far below
performing \code{l} full high-precision Mandelbrot updates.

\subsection{LA v2 linear approximation with perturbation (HDR kernel)}
\label{sec:la-v2-perturb}

This kernel family combines staged linear-approximation steps introduced by
Zhuoran in the Imagina viewer \cite{Imagina} with a
perturbation finisher loop against a stored reference orbit
(see \cref{sec:perturb-only} for the perturbation-only variant). The rendering
objective remains escape-time Mandelbrot evaluation; the kernel accelerates
that evaluation by evolving deltas and periodically reconstructing \(z\) to
perform bailout checks.

\subsubsection{Parameter delta per pixel}
Each pixel constructs a parameter offset \(\Delta c\) relative to a selected
reference center (sign conventions may incorporate the image \(Y\)-flip):
\begin{align}
\Delta c_x &= dx\cdot X - \code{centerX}, \\
\Delta c_y &= -dy\cdot Y - \code{centerY},
\end{align}
and packs \(\Delta c=\Delta c_x+i\Delta c_y\) into \code{DeltaSub0}.

\subsubsection{Delta state and reconstruction}
The kernel maintains \(\Delta z_n\) in \code{DeltaSubN} and reconstructs an
absolute orbit estimate using the stored reference orbit sample
\(z_j^\star\):
\[
z \approx z_j^\star + \Delta z.
\]
Escape-time rendering then proceeds by applying approximation steps when valid,
or performing perturbation updates otherwise, while periodically testing the
bailout condition on the reconstructed \(z\).

\subsubsection{Perturbation update}
Given a reference sample \(z^\star=x^\star+iy^\star\) and \(\Delta z=\Delta
x+i\Delta y\), the perturbation form is:
\[
\Delta z \leftarrow \Delta z\cdot(2z^\star+\Delta z) + \Delta c.
\]
In real arithmetic, with temporaries corresponding to \((2x^\star+\Delta x)\)
and \((2y^\star+\Delta y)\), this yields:
\begin{align}
\Delta x' &= \Delta x\,(2x^\star+\Delta x) - \Delta y\,(2y^\star+\Delta y) + \Delta c_x, \\
\Delta y' &= \Delta x\,(2y^\star+\Delta y) + \Delta y\,(2x^\star+\Delta x) + \Delta c_y,
\end{align}
where both right-hand sides use the pre-update values of \(\Delta x\) and
\(\Delta y\) (the code saves these as \code{DeltaSubNXOrig} and
\code{DeltaSubNYOrig}).

\subsubsection{Escape test}
After updating \(\Delta z\), reconstruct \(z\approx z^\star+\Delta z\) and test:
\[
|z|^2 = x^2+y^2 \ge 4 \quad\Rightarrow\quad \text{escaped.}
\]
For HDR/expanded types, norms and comparisons are performed using reduced values
and specialized reduced comparators, preserving meaningful bailout decisions at
deep zoom.

\subsubsection{LA coefficient model}
\label{sec:la-coeff-model}

The LA v2 algorithm approximates the perturbation delta after multiple
iterations as a linear function of two quantities: a nonlinearly transformed
input perturbation and the parameter offset.  Concretely, each LA entry stores
a reference orbit value \(z_\mathrm{ref}\) together with two complex
coefficients \code{ZCoeff} and \code{CCoeff}.  Application proceeds in two
stages:
\begin{enumerate}
  \item \textbf{Prepare} (nonlinear).  Given the current perturbation
        \(\Delta z\), compute
        \begin{equation}
        \tilde{\Delta z} = \Delta z\cdot(2\,z_\mathrm{ref} + \Delta z).
        \label{eq:la-prepare}
        \end{equation}
        This retains the quadratic term at the entry's reference point and
        corresponds to one exact perturbation step (without the
        \(+\Delta c\) contribution).  The Prepare step also checks the
        validity condition
        \(\lVert\tilde{\Delta z}\rVert_\infty < \code{LAThreshold}\);
        if this fails the LA entry is unusable and the kernel falls back
        to a finer stage or to direct perturbation.

  \item \textbf{Evaluate} (linear).  The output perturbation after the
        iterations covered by this LA entry is
        \begin{equation}
        \Delta z_\mathrm{out}
          = \code{ZCoeff}\cdot\tilde{\Delta z}
          + \code{CCoeff}\cdot\Delta c.
        \label{eq:la-evaluate}
        \end{equation}
\end{enumerate}
In the code, \code{LAInfoDeep::Prepare} implements~\cref{eq:la-prepare}
and \code{LAInfoDeep::Evaluate} implements~\cref{eq:la-evaluate}.

The initial conditions, set in the \code{LAInfoDeep} constructor, are
\[
\code{ZCoeff}_0 = 1,\qquad \code{CCoeff}_0 = 1,\qquad
\code{LAThreshold}_0 = 1,\qquad \code{LAThresholdC}_0 = 1,\qquad
\code{MinMag}_0 = 4.
\]
The initial \(\code{CCoeff}_0 = 1\) accounts for the single \(+\Delta c\)
contribution implicit in combining the Prepare step with one perturbation
iteration: \(\Delta z_\mathrm{next} = \tilde{\Delta z} + \Delta c\), so
\(\Delta z_\mathrm{out} = 1\cdot\tilde{\Delta z} + 1\cdot\Delta c\).
The thresholds start at~1 (no restriction) and tighten monotonically as
iterations are absorbed.  \code{MinMag} starts at~4 (the bailout radius
squared), ensuring any orbit value below the bailout can trigger
period detection.

\subsubsection{Step-forward recurrence}
\label{sec:la-step-forward}

Each call to \code{LAInfoDeep::Step} absorbs one additional reference-orbit
iteration into an LA entry by appending a linearized perturbation step.
Starting from the exact perturbation recurrence (dropping the quadratic
\((\Delta z)^2\) term for subsequent iterations after Prepare):
\[
\Delta z_{n+1} \approx 2\,z_n^\star\,\Delta z_n + \Delta c,
\]
and substituting the LA model
\(\Delta z_n \approx \code{ZCoeff}_k\cdot\tilde{\Delta z}
                    + \code{CCoeff}_k\cdot\Delta c\), we obtain
\begin{align}
\Delta z_{n+1}
  &\approx 2\,z_n^\star\bigl(
      \code{ZCoeff}_k\cdot\tilde{\Delta z}
    + \code{CCoeff}_k\cdot\Delta c
    \bigr) + \Delta c \\
  &= \bigl(2\,z_n^\star\cdot\code{ZCoeff}_k\bigr)\,\tilde{\Delta z}
   + \bigl(2\,z_n^\star\cdot\code{CCoeff}_k + 1\bigr)\,\Delta c.
\end{align}
Reading off the coefficients gives the step-forward recurrence:
\begin{equation}
\code{ZCoeff}_{k+1} = 2\,z_n^\star\cdot\code{ZCoeff}_k,\qquad
\code{CCoeff}_{k+1} = 2\,z_n^\star\cdot\code{CCoeff}_k + 1.
\label{eq:la-step}
\end{equation}

\paragraph{Connection to the orbit derivative.}
The \code{CCoeff} recurrence
\(C_{k+1} = 2\,z_n^\star\,C_k + 1\) with \(C_0 = 1\)
is identical in form to the orbit derivative recurrence
\(d_{n+1} = 2\,z_n\,d_n + 1\) with \(d_0 = 0\)
(\cref{subsec:ref-orbit-periodicity}), offset by one step.
This is not a coincidence: \code{CCoeff} accumulates the total
sensitivity \(\partial z_n / \partial c\) of the orbit position to
changes in the parameter, which is exactly the orbit derivative.  The
\(+1\) in each step reflects the direct \(+\Delta c\) contribution from
the Mandelbrot recurrence \(z_{n+1} = z_n^2 + c\).

\subsubsection{Validity threshold}
\label{sec:la-threshold}

The linearization underlying the step-forward recurrence introduces error
whenever the neglected quadratic term \((\Delta z)^2\) is non-negligible.
To control this, each LA entry tracks a validity threshold
\code{LAThreshold} that bounds how large the prepared perturbation
\(\tilde{\Delta z}\) may be.  Each step tightens the bound:
\begin{equation}
\code{LAThreshold}_{k+1}
  = \min\!\bigl(
      \code{LAThreshold}_k,\;
      \lVert z^\star\rVert_\infty \,/\,
      \lVert\code{ZCoeff}_k\rVert_\infty
      \;\cdot\;\code{LAThresholdScale}
    \bigr),
\label{eq:la-threshold}
\end{equation}
where \(\lVert\cdot\rVert_\infty\) is the Chebyshev (max-component) norm,
\(\lVert a + bi \rVert_\infty = \max(|a|, |b|)\), and
\code{LAThresholdScale} is a tunable parameter (default \(2^{-24}\)).
The \(\min\) ensures the threshold can only decrease as more iterations are
absorbed, reflecting the accumulation of linearization error.

\paragraph{Parameter-offset threshold (\code{LAThresholdC}).}
A companion threshold \code{LAThresholdC} controls validity with respect
to the parameter offset \(\Delta c\).  It follows the same monotonically
decreasing pattern but is normalized by \(\lVert\code{CCoeff}\rVert\):
\begin{equation}
\code{LAThresholdC}_{k+1}
  = \min\!\bigl(
      \code{LAThresholdC}_k,\;
      \lVert z^\star\rVert_\infty \,/\,
      \lVert\code{CCoeff}_k\rVert_\infty
      \;\cdot\;\code{LAThresholdCScale}
    \bigr).
\label{eq:la-threshold-c}
\end{equation}
Before entering a stage's LA loop, the kernel checks whether the pixel's
parameter offset is within the stage's validity range:
\[
\lVert \Delta c \rVert_\infty \ge \code{LAThresholdC}
  \quad\Longrightarrow\quad
  \text{skip this stage entirely.}
\]
This gate avoids wasting work on LA steps that would immediately fail the
Prepare validity check.  It is the \code{isLAStageInvalid} test in the
code.

\subsubsection{Composing LA entries}
\label{sec:la-composite}

Two consecutive LA entries can be merged into a single entry covering their
combined iteration span.  If LA\(_1\) covers iterations \([a,b)\) with
coefficients \((\code{ZCoeff}_1, \code{CCoeff}_1)\) and reference
\(z_\mathrm{ref,1}\), and LA\(_2\) covers \([b,c)\) with
\((\code{ZCoeff}_2, \code{CCoeff}_2)\) and reference \(z_\mathrm{ref,2}\),
then composing them requires one linearized Prepare step at the boundary
(dropping the quadratic term):
\begin{align}
\code{ZCoeff}_\mathrm{comp}
  &= 2\,z_\mathrm{ref,2}\cdot\code{ZCoeff}_1\cdot\code{ZCoeff}_2,
  \label{eq:la-comp-z} \\
\code{CCoeff}_\mathrm{comp}
  &= 2\,z_\mathrm{ref,2}\cdot\code{CCoeff}_1\cdot\code{ZCoeff}_2
   + \code{CCoeff}_2.
  \label{eq:la-comp-c}
\end{align}
This is analogous to BLA composition (\cref{sec:bilinear-approx}):
the \code{ZCoeff} factors multiply and the \code{CCoeff} factors compose
as an affine chain.  The factor \(2\,z_\mathrm{ref,2}\) accounts for
the linearized Prepare step at the junction between the two entries.
The composite's reference is set to \(z_\mathrm{ref,1}\), since the
composite's Prepare step operates at the first entry's starting point.

\paragraph{Threshold propagation during composition.}
The composite thresholds are \emph{not} simply the minimum of the two
entries' thresholds.  The computation proceeds in two stages.  First,
one Step-like tightening is applied at the junction point:
\begin{align}
T_\mathrm{junc}
  &= \min\!\bigl(
       \code{LAThreshold}_1,\;
       \lVert z_\mathrm{ref,2} \rVert_\infty
       \,/\, \lVert \code{ZCoeff}_1 \rVert_\infty
       \cdot \code{LAThresholdScale}
     \bigr),
\label{eq:la-comp-thresh-junc}
\\
T_{C,\mathrm{junc}}
  &= \min\!\bigl(
       \code{LAThresholdC}_1,\;
       \lVert z_\mathrm{ref,2} \rVert_\infty
       \,/\, \lVert \code{CCoeff}_1 \rVert_\infty
       \cdot \code{LAThresholdCScale}
     \bigr).
\end{align}
Then the intermediate product
\(Z' = 2\,z_\mathrm{ref,2} \cdot \code{ZCoeff}_1\) is formed
(this is the ZCoeff \emph{before} multiplication by \code{ZCoeff}\(_2\)).
The second entry's threshold is rescaled by this amplification:
\begin{align}
\code{LAThreshold}_\mathrm{comp}
  &= \min\!\bigl(
       T_\mathrm{junc},\;
       \code{LAThreshold}_2 \,/\, \lVert Z' \rVert_\infty
     \bigr),
\\
\code{LAThresholdC}_\mathrm{comp}
  &= \min\!\bigl(
       T_{C,\mathrm{junc}},\;
       \code{LAThreshold}_2 \,/\, \lVert C' \rVert_\infty
     \bigr),
\end{align}
where \(C' = 2\,z_\mathrm{ref,2} \cdot \code{CCoeff}_1\).
The rescaling by \(\lVert Z' \rVert_\infty\) accounts for the fact that
the prepared perturbation entering LA\(_2\) is amplified by the first
entry's coefficients; the second entry's threshold must be correspondingly
tightened.

In the code, \code{LAInfoDeep::Composite} implements this operation and
is used by \code{CreateNewLAStage} to build higher-level stages from
lower-level ones.

\subsubsection{Period-aligned stage hierarchy}
\label{sec:la-stage-hierarchy}

The power of LA v2 comes from aligning the approximation hierarchy with
the reference orbit's periodic structure.
The construction, implemented in \code{LAReference::CreateLAFromOrbit}
and \code{CreateNewLAStage}, proceeds as follows:
\begin{enumerate}
  \item \textbf{Period detection (stage~0).}  The algorithm scans the
        reference orbit, accumulating LA coefficients via the step-forward
        recurrence (\cref{eq:la-step}).  At each step~\(k\), a
        \emph{period-detection test} is evaluated; when the test fires,
        a period boundary is recorded and the accumulated
        coefficients are stored as one stage-0 LA entry.  Each stage-0
        entry therefore covers approximately one period \(p\) of the
        reference orbit.

        Two period-detection methods are available (the choice is a
        run-time parameter, \code{DetectionMethod}):
        \begin{itemize}
          \item \textbf{Method~1 (minimum-magnitude).}  The algorithm
                tracks
                \[
                \code{MinMag}_k = \min_{0 \le j \le k}
                  \lVert z_j^\star \rVert_\infty.
                \]
                A period is detected at step~\(k\) when
                \begin{equation}
                \lVert z_k^\star \rVert_\infty
                  < \code{MinMag}_{k-1}
                    \cdot \code{Stage0PeriodDetectionThreshold2}.
                \label{eq:period-detect-minmag}
                \end{equation}
                Intuitively, if the orbit revisits a neighborhood
                smaller than any previously seen, it is nearly periodic.
                This is the default method.

          \item \textbf{Method~2 (coefficient ratio).}  A period is
                detected when the threshold tightening at the current
                step exceeds a fraction of the existing threshold:
                \begin{equation}
                \frac{\lVert z_k^\star \rVert_\infty}
                     {\lVert \code{ZCoeff}_k \rVert_\infty}
                \cdot \code{LAThresholdScale}
                < \code{LAThreshold}_k
                  \cdot \code{Stage0PeriodDetectionThreshold}.
                \label{eq:period-detect-coeff}
                \end{equation}
                This variant reuses the threshold machinery directly.
        \end{itemize}
        For higher stages (stage~1 and above), the same tests are
        applied during the Composite pass, with separate threshold
        constants \code{PeriodDetectionThreshold2} and
        \code{PeriodDetectionThreshold} (typically looser than the
        stage-0 variants).

  \item \textbf{Recursive composition (stages~1, 2, \ldots).}
        \code{CreateNewLAStage} builds the next stage by composing
        consecutive entries from the previous stage using the Composite
        operation (\cref{eq:la-comp-z,eq:la-comp-c}).  Period detection
        is applied again at this level, so each stage-1 entry covers
        many periods, each stage-2 entry covers many stage-1 entries,
        and so on.  Construction repeats until no further period is
        detected.

  \item \textbf{Fallback for aperiodic orbits.}  If no period is
        detected within the first \code{lowBound} iterations, the
        algorithm synthesizes an artificial period as
        \(\lfloor M^{1/k}\rfloor\) (where \(M\) is the total iteration
        count and \(k\) is derived from \code{periodDivisor}) and
        proceeds with that period length.  This ensures LA v2 provides
        some acceleration even for non-periodic reference orbits,
        though the skip lengths will be shorter.

  \item \textbf{Subdivision of large periods.}  If a true period
        \emph{is} detected but exceeds a threshold (64~entries at
        stage~0, or \(64 \times\) the previous stage's step length at
        higher stages), it is too large for efficient LA traversal.
        The algorithm discards the detected entry and restarts with a
        synthetic logarithmic subdivision of the detected period,
        using the same \(\lfloor p^{1/k}\rfloor\) formula applied to
        the period~\(p\) instead of the total iteration count.
        This keeps each stage's entry count manageable.
\end{enumerate}

The key insight is that near a mini-Mandelbrot copy, the orbit nearly
repeats every \(p\) iterations, so the linear approximation remains valid
across an entire period---the threshold barely tightens.  A single
stage-0 LA entry can therefore skip \(p\) iterations, and higher-stage
entries skip \(k\cdot p\) or more.

The GPU kernel (\code{LAKernel.cuh}) exploits this by descending through
stages from coarsest to finest.  In the inner loop,
successive LA steps advance the iteration counter by the entry's
\code{StepLength} each time---typically covering the vast majority of
total iterations via the linear path.  Only when the LA threshold is
exceeded does the kernel fall through to the perturbation loop, which
handles a typically small fraction of remaining iterations.

\paragraph{Inter-stage fallback via \code{NextStageLAIndex}.}
Each LA entry stores, alongside its \code{StepLength}, a field
\code{NextStageLAIndex} that records the iteration offset into the
\emph{next finer} stage where this entry's span begins.  When a
Prepare check fails at stage~\(s\), the kernel does not simply
restart from entry~0 of stage~\(s-1\); instead, it resumes at
macro-iteration index \code{NextStageLAIndex}, which points to the
correct position within stage~\(s-1\)'s entry array.  This avoids
redundant re-traversal of entries in the finer stage that precede the
current iteration.  The kernel's outer loop decrements
\code{CurrentLAStage} and the inner loop initializes its entry index~\(j\)
from the stored \code{RefIteration}, which was set to
\code{NextStageLAIndex} when the previous stage's step failed.

Within the LA evaluation loop, a \emph{rebasing} check is performed after
each step: if
\(\lVert \Delta z \rVert_\infty > \lVert z \rVert_\infty\)
(the perturbation has grown larger than the reconstructed orbit), the
kernel sets \(\Delta z \leftarrow z\) and restarts the macro-iteration
counter at entry~0 of the current stage.  This mirrors the rebasing
mechanism in perturbation-only rendering (\cref{sec:perturb-only-rebase}).

\subsubsection{Attractor transformation (AT)}
\label{sec:attractor-transform}

When the pixel lies deep inside a mini-Mandelbrot copy, the LA hierarchy
enables a further optimization: the \emph{attractor transformation}.
Rather than iterating the perturbation against a stored reference orbit,
the AT maps the pixel into a coordinate system where plain Mandelbrot
iteration \(w_{n+1} = w_n^2 + c_w\) (with no reference orbit) reproduces
the orbit's behavior at the scale of one full period per iteration.

\paragraph{Construction.}
The AT is constructed from the first entry of a stage's LA array.
The algorithm iterates from the topmost (coarsest) stage downward,
attempting to construct an AT at each level.  The first stage whose
AT passes the usability check (\cref{sec:at-usability} below) is
selected; if no stage produces a usable AT, the optimization is
disabled for this reference.  For the selected stage, let the first
entry have coefficients \code{ZCoeff}, \code{CCoeff} and let the
\emph{next} entry's reference be \(z_\mathrm{ref,next}\).  The
transformation parameters are:
\begin{align}
\code{AT.ZCoeff}   &= \code{ZCoeff}, \\
\code{AT.CCoeff}   &= \code{ZCoeff} \cdot \code{CCoeff}, \\
\code{AT.InvZCoeff}&= 1 \,/\, \code{AT.ZCoeff}, \\
\code{AT.RefC}     &= z_\mathrm{ref,next} \cdot \code{ZCoeff}
  \quad\text{(converted to low precision)}, \\
\code{AT.SqrEscapeRadius} &= \min\bigl(
      \lVert\code{ZCoeff}\rVert^2 \cdot \code{LAThreshold},\;
      2^{256}\bigr), \\
\code{AT.ThresholdC} &= \min\bigl(
      \code{LAThresholdC},\;
      2^{256} \,/\, \lVert\code{AT.CCoeff}\rVert_\infty\bigr).
\end{align}

\paragraph{Usability check.}
\label{sec:at-usability}
The AT is declared usable when two conditions hold:
\begin{enumerate}
  \item The pixel radius (squared) scaled by the CCoeff amplification
        exceeds the reference magnitude:
        \[
        R^2 \cdot \lVert\code{AT.CCoeff}\rVert^2 \cdot 2^{32}
          > \lVert\code{AT.RefC}\rVert^2.
        \]
  \item The transformed escape radius exceeds the standard bailout:
        \(\code{AT.SqrEscapeRadius} > 4\).
\end{enumerate}
If the AT is unusable (e.g.\ because the zoom is too shallow or the
LA entry's threshold is too tight), the kernel falls back to the
normal LA stage traversal.

\paragraph{Evaluation.}
For each pixel with parameter offset \(\Delta c\), the kernel transforms
to AT space:
\[
c_w = \Delta c \cdot \code{AT.CCoeff} + \code{AT.RefC},
\]
then iterates the standard Mandelbrot recurrence
\(w_{n+1} = w_n^2 + c_w\) with bailout
\(|w|^2 \ge \code{AT.SqrEscapeRadius}\).  Crucially, no reference-orbit
lookups are needed---just scalar iteration.  Each AT iteration corresponds
to \code{StepLength} original Mandelbrot iterations (one full period).

After AT termination (escape or max-iteration), the kernel transforms
back to perturbation space:
\[
\Delta z = w \cdot \code{AT.InvZCoeff},
\]
and resumes with the LA stage traversal or perturbation loop for the
remaining iterations.

\paragraph{Significance.}
The AT provides a dramatic speedup when applicable.  At deep zoom near
a period-\(p\) mini-Mandelbrot, the AT reduces the effective iteration
count from \(N\) to roughly \(N/p\), with each iteration being a simple
scalar multiply-add rather than a reference-orbit lookup plus
perturbation.  The AT is essentially the observation that the
Mandelbrot set is self-similar at mini-copies, and this self-similarity
can be made computationally explicit.

\subsubsection{Precision selection per stage}
\label{sec:la-dp-conversion}

When the LA coefficients and thresholds for a stage remain comfortably
within double-precision range, the stage can be evaluated using
\code{double} arithmetic instead of the full HDR (high-dynamic-range)
representation.  During LA construction, each stage is tested: if
\(\code{LAThreshold} > 2^{-768}\) and
\(\code{LAThresholdC} > 2^{-768}\) (or, equivalently, the zoom radius
exceeds \(2^{-896}\)), the stage's \code{LAInfo<HRReal>} entries are
converted in-place to \code{LAInfo<double>} via
\code{ConvertStageToDouble}.  A per-stage flag
\code{UseDoublePrecision} records this choice.

During evaluation, the kernel dispatches double-precision arithmetic for
flagged stages and HDR arithmetic for the rest.  Since the inner stages
(closest to the reference orbit) are the most likely to require HDR
precision, while outer stages (covering many periods) often fit in
double, this hybrid approach concentrates the expensive HDR work where
it is needed.  Similarly, the perturbation tail loop may use
double precision when flagged by \code{DoublePrecisionPT}.

\subsubsection{Derivative propagation through LA steps}
\label{sec:la-derivatives}

For distance-estimation coloring, the kernel must propagate the orbit
derivatives \(\partial z / \partial z_0\) (denoted \code{dzdz}) and
\(\partial z / \partial c\) (denoted \code{dzdc}) through LA steps, not
just the perturbation delta.  Given a single LA step with coefficients
\((\code{ZCoeff}, \code{CCoeff})\) and reference \(z_\mathrm{ref}\), the
derivative updates are:
\begin{align}
\code{dzdz}' &= \code{dzdz}
  \;\cdot\; 2\,(\Delta z + z_\mathrm{ref})
  \;\cdot\; \code{ZCoeff},
\label{eq:la-dzdz}
\\
\code{dzdc}' &= \code{dzdc}
  \;\cdot\; 2\,(\Delta z + z_\mathrm{ref})
  \;\cdot\; \code{ZCoeff}
  \;+\; \code{CCoeff} \cdot S,
\label{eq:la-dzdc}
\end{align}
where \(S\) is a scaling factor used to keep the derivative magnitudes
within representable range (rescaled periodically during evaluation).
The factor \(2\,(\Delta z + z_\mathrm{ref})\) is the derivative of the
Prepare step, and \code{ZCoeff} propagates through the linearized
iterations.  These updates are applied \emph{before}
\code{Evaluate} updates \(\Delta z\) itself, so \(\Delta z\) in the
formulas above is the pre-step value.

\subsubsection{Comparison with BLA}
\label{sec:la-vs-bla}

BLA (\cref{sec:bilinear-approx}) and LA v2 share the same underlying
linear-map form \(\Delta z \mapsto A\,\Delta z + B\,\Delta c\), but
differ in hierarchy design and accuracy:
\begin{itemize}
  \item \textbf{Hierarchy structure.}  BLA builds a generic binary tree
        of composed steps at power-of-two granularity (levels
        \(1, 2, 4, 8, \ldots\)), agnostic of the orbit's dynamics.
        LA v2 builds a multi-stage hierarchy aligned to the orbit's
        detected period, so each stage-0 entry covers one period and
        higher stages cover multiples of the period.

  \item \textbf{Period awareness.}  BLA has no notion of periodicity;
        it treats the reference orbit as an opaque sequence.  LA v2
        explicitly detects the period and exploits the fact that near a
        periodic point, the orbit nearly repeats---making the linear
        approximation accurate over the entire period and enabling much
        larger skip lengths.

  \item \textbf{Prepare step.}  BLA applies a purely linear map at every
        step.  LA v2 applies a nonlinear Prepare step
        (\cref{eq:la-prepare}) that retains the quadratic term at each
        entry's reference point, then linearizes only the subsequent
        iterations.  This provides better accuracy per LA step.

  \item \textbf{Kernel structure.}  The BLA kernel interleaves single
        perturbation steps with greedy BLA lookups: do one perturbation
        step, scan the hierarchy for the longest valid BLA skip, apply
        it, and repeat.  The LA v2 kernel is two-phase: first descend
        through LA stages (applying period-length jumps in the inner
        loop), then fall through to perturbation for the tail.
\end{itemize}
In practice, LA v2's period alignment enables it to skip a much larger
fraction of total iterations via the linear path compared with BLA's
generic power-of-two hierarchy, particularly at deep zooms where the
view is dominated by a mini-Mandelbrot copy with a well-defined period.


